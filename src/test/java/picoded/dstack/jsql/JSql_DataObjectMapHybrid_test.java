package picoded.dstack.jsql;

// Target test class
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.RandomUtils;
// Test Case include
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import picoded.core.conv.ConvertJSON;
import picoded.core.conv.GUID;
import picoded.core.struct.GenericConvertHashMap;
import picoded.core.struct.GenericConvertMap;
// Test depends
import picoded.dstack.DataObject;
import picoded.dstack.DataObjectMap;
import picoded.dstack.connector.jsql.JSql;

public class JSql_DataObjectMapHybrid_test {
	
	// To override for implementation
	// -----------------------------------------------------
	JSql jsql;
	
	/// Note that this SQL connector constructor
	/// is to be overriden for the various backend
	/// specific test cases
	public JSql jsqlConnection() {
		if (jsql != null) {
			return jsql;
		}
		jsql = JSqlTestConnection.sqlite();
		return jsql;
	}
	
	private DataObjectMap mtObj;
	String fixedTableName;
	
	/// Impomentation constructor for SQL
	public DataObjectMap implementationConstructor() {
		GenericConvertMap<String, Object> dataObjectMap = new GenericConvertHashMap<>();
		GenericConvertMap<String, Object> fixedTableMap = new GenericConvertHashMap<>();
		Map<String, Object> fixedTable = new HashMap<>();
		Map<String, Object> oid = new HashMap<>();
		oid.put("name", "OID");
		fixedTable.put("_oid", oid);
		fixedTable.put("FULL_NAME", "VARCHAR(256)");
		fixedTable.put("NRIC", "VARCHAR(32)");
		fixedTable.put("OCCUPATION", "VARCHAR(256)");
		fixedTableMap.put(fixedTableName, fixedTable);
		dataObjectMap.put("fixedTableMap", fixedTableMap);
		return new JSql_DataObjectMap(jsqlConnection(), JSqlTestConfig.randomTablePrefix(),
			dataObjectMap);
	}
	
	public void createDatabase() {
		jsqlConnection().createTable( //
			fixedTableName, //
			new String[] { //
			// Primary key, as classic int, this is used to lower SQL
			// fragmentation level, and index memory usage. And is not accessible.
			// Sharding and uniqueness of system is still maintained by GUID's
				"pKy", //
				// Time stamps
				"cTm", // value created time
				"uTm", // value updated time
				"eTm", // value expire time (for future use)
				// Object keys
				"oID", // _oid
				"full_name", // key storage
				"nric", // index collumn
				"occupation" // type collumn
			}, //
			new String[] { //
			"BIGINT PRIMARY KEY AUTOINCREMENT", // Primary key
				// Time stamps
				"BIGINT", //
				"BIGINT", //
				"BIGINT", //
				// Object keys
				"VARCHAR(64)", //
				"VARCHAR(256)", //
				"VARCHAR(32)", //
				"VARCHAR(256)", //
			} //
			);
	}
	
	public List<String> populatedOID;
	
	public void populateDatabase() {
		populatedOID = new ArrayList<>();
		
		// Prepare the large multiUpsert values
		List<Object[]> uniqueValuesList = new ArrayList<Object[]>();
		List<Object[]> insertValuesList = new ArrayList<Object[]>();
		List<Object[]> defaultValuesList = new ArrayList<Object[]>();
		
		for (int i = 0; i < 5; i++) {
			String oid = GUID.base58();
			// Setup the multiUpsert
			uniqueValuesList.add(new Object[] { oid });
			insertValuesList.add(new Object[] { "Testing " + i,
				RandomStringUtils.randomAlphanumeric(32), RandomStringUtils.randomAlphanumeric(60) });
			defaultValuesList.add(new Object[] { System.currentTimeMillis() });
			populatedOID.add(oid);
		}
		
		// Insert a row that is not Testing
		String random_name = RandomStringUtils.randomAlphanumeric(32);
		uniqueValuesList.add(new Object[] { GUID.base58() });
		insertValuesList.add(new Object[] { random_name, RandomStringUtils.randomAlphanumeric(32),
			RandomStringUtils.randomAlphanumeric(60) });
		defaultValuesList.add(new Object[] { System.currentTimeMillis() });
		
		// Insert into tables
		jsqlConnection().multiUpsert(fixedTableName, // Table name to upsert on
			// "pKy" is auto generated by SQL db
			new String[] { "oID" }, // The unique column names
			uniqueValuesList, // The row unique identifier values
			// Value / Text / Raw storage + Updated / Expire time stamp
			new String[] { "full_name", "nric", "occupation" }, //
			insertValuesList, //
			// Created timestamp setup
			new String[] { "cTm" }, //
			defaultValuesList, //
			null // The only misc col, is pKy, which is being handled by DB
			);
	}
	
	@Before
	public void setup() {
		fixedTableName = JSqlTestConfig.randomTablePrefix();
		createDatabase();
		populateDatabase();
		mtObj = implementationConstructor();
		mtObj.systemSetup();
	}
	
	@After
	public void destroy() {
		if (mtObj != null) {
			mtObj.systemDestroy();
		}
		mtObj = null;
		
		if (jsql != null) {
			jsql.close();
		}
	}
	
	@Test
	public void retrieveValidObjectShouldPass() {
		String oid = populatedOID.get(RandomUtils.nextInt(0, populatedOID.size()));
		DataObject obj = mtObj.get(oid);
		assertNotNull(obj);
		assertEquals(oid, obj._oid());
	}
	
	@Test
	public void retrieveInvalidObjectShouldReturnNull() {
		DataObject obj = mtObj.get(RandomStringUtils.randomAlphanumeric(32));
		assertNull(obj);
	}
	
	@Test
	public void queryValidObjectShouldReturnResult() {
		int number = RandomUtils.nextInt(0, populatedOID.size());
		DataObject[] objs = mtObj.query("FULL_NAME = ? ", new Object[] { "Testing " + number });
		
		assertNotNull(objs);
		assertEquals(1, objs.length);
		assertEquals("Testing " + number, objs[0].get("FULL_NAME"));
	}
	
	@Test
	public void queryInvalidObjectShouldReturnNothing() {
		DataObject[] objs = mtObj.query("FULL_NAME = ? ",
			new Object[] { RandomStringUtils.randomAlphanumeric(32) });
		
		assertNotNull(objs);
		assertEquals(0, objs.length);
	}
	
	@Test
	public void deleteValidObjectShouldPass() {
		String oid = populatedOID.get(RandomUtils.nextInt(0, populatedOID.size()));
		
		DataObject beforeDelete = mtObj.get(oid);
		assertNotNull(beforeDelete);
		assertEquals(oid, beforeDelete._oid());
		
		// Remove
		mtObj.remove(oid);
		
		// Check that it is gone
		DataObject nonExistence = mtObj.get(oid);
		assertNull(nonExistence);
	}
	
	@Test
	public void createNewObjectInHybridShouldPass() {
		GenericConvertMap<String, Object> properties = new GenericConvertHashMap<>();
		properties.put("full_name", RandomStringUtils.randomAlphanumeric(32));
		properties.put("nric", RandomStringUtils.randomAlphanumeric(32));
		properties.put("occupation", RandomStringUtils.randomAlphanumeric(32));
		properties.put("random_attribute", RandomStringUtils.randomAlphanumeric(32));
		DataObject newObj = mtObj.newEntry(properties);
		newObj.saveAll();
		
		// grab and verify
		DataObject created = mtObj.get(newObj._oid());
		assertEquals(newObj._oid(), created._oid());
		assertEquals(properties.getString("full_name"), created.getString("full_name"));
		assertEquals(properties.getString("nric"), created.getString("nric"));
		assertEquals(properties.getString("occupation"), created.getString("occupation"));
		assertEquals(properties.getString("random_attribute"), created.getString("random_attribute"));
	}
	
	@Test
	public void updateExistingObjectShouldBeSuccessful() {
		GenericConvertMap<String, Object> properties = new GenericConvertHashMap<>();
		properties.put("full_name", RandomStringUtils.randomAlphanumeric(32));
		properties.put("nric", RandomStringUtils.randomAlphanumeric(32));
		properties.put("occupation", RandomStringUtils.randomAlphanumeric(32));
		properties.put("random_attribute", RandomStringUtils.randomAlphanumeric(32));
		
		String oid = populatedOID.get(RandomUtils.nextInt(0, populatedOID.size()));
		
		DataObject currentObj = mtObj.get(oid);
		
		assertEquals(oid, currentObj._oid());
		assertNotEquals(properties.getString("full_name"), currentObj.getString("full_name"));
		assertNotEquals(properties.getString("nric"), currentObj.getString("nric"));
		assertNotEquals(properties.getString("occupation"), currentObj.getString("occupation"));
		assertNotEquals(properties.getString("random_attribute"),
			currentObj.getString("random_attribute"));
		
		// Update it and save it
		currentObj.putAll(properties);
		currentObj.saveDelta();
		
		// grab and verify
		DataObject updatedObj = mtObj.get(oid);
		assertEquals(currentObj._oid(), updatedObj._oid());
		assertEquals(properties.getString("full_name"), updatedObj.getString("full_name"));
		assertEquals(properties.getString("nric"), updatedObj.getString("nric"));
		assertEquals(properties.getString("occupation"), updatedObj.getString("occupation"));
		assertEquals(properties.getString("random_attribute"),
			updatedObj.getString("random_attribute"));
	}
	
	@Test
	public void listingDataObjectWithSimilarShouldReturn() {
		DataObject[] objs = mtObj.query("FULL_NAME LIKE ? ", new Object[] { "%Testing%" });
		
		assertNotNull(objs);
		assertEquals(5, objs.length);
		for (DataObject obj : objs) {
			assertTrue(obj.getString("FULL_NAME").startsWith("Testing "));
		}
	}
}